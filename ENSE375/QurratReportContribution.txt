Git Remotes
Remotes are simply a repository in another location on the Internet or network from where the user is currently working. They are very useful in projects that require collaborations, and users can have multiple remote repositories that can be read/write or read only depending on user tasks. For instance, if the user is working on a local repository on their laptop, and they also have a version of that work on GitHub, then from the perspective of the laptop, GitHub is a remote repository.
	In order to create a remote repository on the user’s local laptop from GitHub, they will need to use the “git clone” command to retrieve the project from GitHub. The command “git clone” is executed using either an SSH key or HTTPS address. It provides the user with an address that allows them to clone their repository from GitHub to their local laptop. After using “git clone”, the default remote that is created is called “origin”. Origin refers to the default name Git gives to the server that the user clones from. It can be useful for developers that need to create multiple repositories and need to signify a central repository to push and pull updates from.

Remote Branches
	Remote branches are branches created on a remote location, such as the central repository. For instance, if a user were to push a local branch to the remote origin, it becomes a remote branch that other users can track as well. In general, remote branches point to remote repositories, including branches and tags within those remote repositories, and they sync your local branch with the remote repository branches. 

Adding a Remote Branch
	By default, the remote branch created points to the remote origin. However, when there are multiple users with various editing permissions, they may need to add another remote. To do this, the user first needs to create a fork in GitHub.
	A fork is a copy of a repository that a user can add their own edits or changes to without directly affecting the original repository. Once a user forks the original repository in GitHub, they become the owner of the new repository and can clone it to their local laptop to make changes to it. In this case, the remote named origin would point to the forked repository in GitHub. However, there is a chance that the user would want to stay in sync with the original repository as well. To do this, they would create a second git remote, called an upstream remote. This second remote, an upstream, would point to the original repository.
	When the user fetches an update from the remote upstream, it would update their local repository, as well as the forked repository origin. Once a user runs a “git fetch upstream” command, a new remote tracking branch would be created for the remote upstream.

Tracking Branches
Tracking branches in general are local branches that have a direct relationship with remote branches. In GitHub, when a user uses a tracking branch, they can push and pull from the remote branch without specifying it. One type of commonly used tracking branches is called a “remote tracking branch”.
Remote tracking branches, despite their name, are not actually remote. Remote tracking branches are pointers to the state of the users’ remote branches. They are local branches that a user can’t move themselves, but instead are moved automatically whenever users do any network communication. Remote branches work to remind the user of where the branches on their remote repositories were when they last connected to them. Their main purpose is to serve as a proxy for the actual branch that exists on GitHub. 
A remote tracking branch is created once the first remote is created and committed to GitHub. It tells the user what the master branch looks like at origin. Most commonly, remote tracking branches take the form <remote>/<branch>. So in a default case, the tracking branch is referred to as “origin/master”. As a user can have multiple tracking branches for different remote branches, each branch would be represented by the remote tracking branch “origin/<local-branch>”. 

Git Fetch
	The Git fetch command allows the user to download updates from other repositories. These updates can include updated branches, tags, or other objects necessary to complete their histories (such as tags pointing into the histories). Once fetched, remote tracking branches are updated as well.  Git fetch can fetch from either a single repository or a group of repositories if a group contains multiple remote repositories. If a remote repository isn’t specified, git fetch will automatically download updates from the remote origin, unless there is an upstream branch configured from the current branch. Once the git fetch is completed, it is important use git merge to merge the branches together and catch the user’s local repository up to the remote repository,

Resolving Merge Conflicts
	When there are multiple users working on multiple repositories and trying to push their changes into the central repository, merge conflicts can arise. While there are various ways tor resolve a merge conflict, the easiest way is to use a “git mergetool --tool=emerge” command. 
Git automatically comes with this mergetool, and it specifically works to resolve merge conflicts. Once a user runs this command, they are presented with two versions of their changes. The first one is the version of the code that exists on remote origin. The second version is the code that they are trying to push onto the master branch. They can compare the differences and for each line of code, choose which option of code they prefer in the final merge. Once confirmed, the mergetool merges the code, and the user is left with the optimal version of their code.
